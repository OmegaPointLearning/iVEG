<html>
	<head>
		<title>Interactive Visual Experience Generator - Omega Point Research</title>

		<style>
			.container {
				position: relative;
			}

			.container > canvas {
				position: absolute;
				top: 0;
				left: 0;
			}
		</style>
		
	</head>
	<body>
		<!-- first make the canvas then link any scripts -->
		<div class="container">
			<canvas id="frontground"></canvas>
		</div>

		<script>
			//define some necessary canvas related variables
			const width = window.innerWidth - .2 * window.innerWidth;
			const height = window.innerHeight - .2 * window.innerHeight;

			const frontground = document.getElementById("frontground");
			frontground.width = width;
			frontground.height = height;

			const frontContext = frontground.getContext("2d");

			//shape functions
			const Shapes = {
				classic: {
					shapes: {
						circle: function(context) {
							brush.radius.max = width / 2;
							context.arc(brush.x, brush.y, brush.radius.value, 0, 2 * Math.PI);
						},

						rectangle: function(context) {
							brush.radius.max = width / 4;

							context.rect(brush.x - brush.radius.value, brush.y - brush.radius.value, brush.radius.value * 2, brush.radius.value * 2);
						},

						triangle: function(context) {
							context.moveTo(brush.x, brush.y - brush.radius.value);			
							context.lineTo(brush.x - brush.radius.value, brush.y + brush.radius.value);
							context.lineTo(brush.x + brush.radius.value, brush.y + brush.radius.value);
							context.lineTo(brush.x, brush.y - brush.radius.value);
						},

						star: function(context) {
							brush.radius.max = (2/5) * width;

							context.moveTo(brush.x, brush.y - brush.radius.value);
							context.lineTo(brush.x + (3/5) * brush.radius.value, brush.y + brush.radius.value);
							context.lineTo(brush.x - brush.radius.value, brush.y - (1/5) * brush.radius.value);
							context.lineTo(brush.x + brush.radius.value, brush.y - (1/5) * brush.radius.value);
							context.lineTo(brush.x - (3/5) * brush.radius.value, brush.y + brush.radius.value);
							context.lineTo(brush.x, brush.y - brush.radius.value);
						},

						diamond: function(context) {
							brush.radius.max = width / 2;

							context.moveTo(brush.x, brush.y - (brush.radius.value + .33 * brush.radius.value));
							context.lineTo(brush.x - brush.radius.value, brush.y);
							context.lineTo(brush.x, brush.y + (brush.radius.value + .33 * brush.radius.value));
							context.lineTo(brush.x + brush.radius.value, brush.y);
							context.lineTo(brush.x, brush.y - (brush.radius.value + .33 * brush.radius.value));
						},

						hexagon: function(context) {
							brush.radius.max = width / 2

							context.moveTo(brush.x - brush.radius.value, brush.y);
							context.lineTo(brush.x - (brush.radius.value - .55 * brush.radius.value), brush.y - (.75 * brush.radius.value));
							context.lineTo(brush.x + (brush.radius.value - .55 * brush.radius.value), brush.y - (.75 * brush.radius.value));
							context.lineTo(brush.x + brush.radius.value, brush.y);
							context.lineTo(brush.x + (brush.radius.value - .55 * brush.radius.value), brush.y + (.75 * brush.radius.value));
							context.lineTo(brush.x - (brush.radius.value - .55 * brush.radius.value), brush.y + (.75 * brush.radius.value));
							context.lineTo(brush.x - brush.radius.value, brush.y);
						}
					}
				},

				sauce: {
					data: {
						trigCycles: 0
					},

					shapes: {
						fountain: function(context) {
							brush.radius.max = width / 2;

							context.lineWidth = 2 + ((brush.radius.value / brush.radius.max) * 10);

							let newX = brush.x + Math.floor((Math.random() * 2 * brush.radius.value) - brush.radius.value);
							let newY = brush.y + Math.floor((Math.random() * 2 * brush.radius.value) - brush.radius.value);
							let controlX = width - Math.floor(Math.random() * width) - brush.radius.value;
							let controlY = height - Math.floor(Math.random() * height) - brush.radius.value;

							context.moveTo(brush.x, brush.y);
							context.quadraticCurveTo(controlX, controlY, newX, newY);

							controlX = width - Math.floor(Math.random() * width);
							controlY = height - Math.floor(Math.random() * height);

							context.moveTo(newX, newY);
							context.quadraticCurveTo(controlX, controlY, brush.x, brush.y);
						},

						doubleSine: function(context) {
							brush.radius.max = height / 2;

							context.moveTo(brush.x, brush.y);

							if (Shapes.sauce.data.trigCycles == 2) {
								Shapes.sauce.data.trigCycles = 0;
							} else if (Shapes.sauce.data.trigCycles == 0) {
								context.lineTo(brush.x, brush.y + brush.radius.max * Math.sin((Math.PI / 2) * (brush.radius.value / brush.radius.max)));
							} else {
								context.lineTo(brush.x, brush.y - brush.radius.max * Math.sin((Math.PI / 2) * (brush.radius.value / brush.radius.max)));
							}
							
							if (brush.radius.value == brush.radius.min) {
								Shapes.sauce.data.trigCycles++;
								console.log(Shapes.sauce.data.trigCycles)
							}
						}
					} 
				}
			}

			//foreground brush
			var brush = {
				x: 0,
				y: 0,

				//some brush properties can be passed to the incrementor
				radius: {value: 1, growing: true, min: 0, max: (width / 2), step: 1},

				red: {value: 1, growing: true, min: 0, max: 255, step: 1},
				green: {value: 1, growing: true, min: 0, max: 255, step: 1},
				blue: {value: 1, growing: true, min: 0, max: 255, step: 1},

				//shape is a set of instructions to be called from the draw function
				shape: Shapes.classic.shapes.star,

				//context is where the brush draws to
				context: frontContext
			}

			function draw(brush) {
				let colorCode = "#" + brush.red.value.toString(16) + brush.green.value.toString(16) + brush.blue.value.toString(16);

				brush.context.beginPath();
				brush.context.lineWidth = 2;
				brush.context.strokeStyle = colorCode; 

				brush.shape(brush.context);

				brush.context.stroke();
				brush.context.closePath();
			}

			//general function accepts list of incrementable properties
			function incrementor(propertyList) {
				for (i = 0; i < propertyList.length; i++) {
					let property = propertyList[i];

					if (property.growing == true) {
						property.value += property.step;
					} else {
						property.value -= property.step;
					}

					if (property.value >= property.max) {
						property.growing = false;
					}

					if (property.value <= property.min) {
						property.growing = true;
					}
				}
			}

			//miscelaneous functions that might not get used
			function randomColor(brush) {
				brush.red.value = Math.floor(Math.random() * 255);
				brush.green.value = Math.floor(Math.random() * 255);
				brush.blue.value = Math.floor(Math.random() * 255);
			}

			function colorScroller(brush) {
				if (brush.red.growing == true) {
					incrementor([brush.green, brush.blue]);
				}

				if (brush.green.growing == true) {
					incrementor([brush.red, brush.blue]);
				}

				if (brush.blue.growin == true) {
					incrementor(brush.red, brush.green);
				}
			}

			function changeShape(brush, category) {
				//scrolls through the shapes in a category
				let current = brush.shape.name;
				let keys = Object.keys(category);
				let index = keys.indexOf(current);

				if (index == keys.length - 1) {
					index = 0;
				} else {
					index++;
				}

				let next = keys[index];
				brush.shape = category[next];
			}

			frontground.addEventListener("mousemove", e => {
				brush.x = e.offsetX;
				brush.y = e.offsetY;
				
				incrementor([brush.radius])
				colorScroller(brush)

				if (brush.radius.value == 0) {
					randomColor(brush)

					if (Object.keys(Shapes.classic.shapes).indexOf(brush.shape.name) > -1) {
						changeShape(brush, Shapes.classic.shapes);
					}
				}	
				
				draw(brush);
			});
			
			window.addEventListener("keydown", e => {

				switch(e.key) {
					case "s":
					changeShape(brush, Shapes.sauce.shapes)
					break;

					case "c":
					changeShape(brush, Shapes.classic.shapes);
					break;
				}
			});

		</script>

	</body>
</htnl>